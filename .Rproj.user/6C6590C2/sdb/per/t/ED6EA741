{
    "collab_server" : "",
    "contents" : "#' @param parallel Determines whether package \\code{doParallel} is used for calculation\n#' @param cl Cluster used for parallelization; if it is \\code{NULL}, the system will automatically\n#' @param nrep The number of replications used to compute p-values\n#' @param ninits.crit The number of initial guesses to form critical values \n#' @return A list with the following items:\n#' \\item{crit}{3 by 3 matrix of (0.1, 0.05, 0.01 critical values), jth row corresponding to k=j}\n#' \\item{pvals}{A vector of p-values at k = 1, 2, 3}\nregpanelmixCrit <- function(y, x, parlist, z = NULL, values = NULL, parallel = TRUE,\n                       cl = NULL, nrep = 1000, ninits.crit = 25)\n{\n  # Computes the critical values of the modified EM test\n  # and the estimated variance of the two-component MLE\n  # Input\n  #   y     : n by 1 vector of dependent variable\n  #   x     : n by (q1-1) matrix of regressor not including an intercept\n  #   parlist   : list including (alpha, mubeta, sigma)\n  #   values (q1 by 1): values at wchich the p-values are computed\n  # Output\n  #   list(crit,pvals)\n  #   crit = (10%, 5%, 1% critical values), pvals = p-values\n  n  <- ncol(y)\n  t  <- nrow(y)\n  y  <- as.vector(y)\n  # n  <- length(y)\n  p  <- 0\n  \n  alpha   <- parlist$alpha\n  mubeta  <- parlist$mubeta\n  sigma   <- parlist$sigma\n  gam   <- parlist$gam\n  m       <- length(alpha)\n  \n  if (!is.null(z)) {\n    z <- as.matrix(z)\n    p <- ncol(z)\n    y   <- y - z %*% gam\n  }\n  \n  pvals <- NULL\n  \n  x     <- as.matrix(x)\n  x1    <- cbind(1,x)\n  q     <- ncol(x)\n  \n  # normalized data, W_p, f_p are n by m\n  # W,f are nt by m\n  W  <- t(t(matrix(rep.int(y,m), ncol=m) - x1 %*% mubeta)/sigma)       \n  W_T <- matrix(0,ncol = m, nrow = n) #Sum of error\n  f  <- t(t(exp(-W^2/2)/sqrt(2*pi))/sigma)  # pdf, nt by m\n  f_T <- matrix(0,ncol=m,nrow=n)\n  for (j in 1:m){\n    W_T[,j] <- colSums(matrix(W[,j],nr=t))\n    f_T[,j] <- exp(colSums(matrix(-(W[,j])^2/2,nr=t)))/(sqrt(2*pi)^t)/(sigma[j]^t)\n  }\n  \n  f0 <- colSums(t(f)*alpha)                 # data pdf, nt by 1 \n  f0_T <- colSums(t(f_T)*alpha)                 # data pdf, n by 1\n  \n  H <- hermite(W,sigma)\n  \n  w_m <- t(t(f)*alpha)/f0  # nt by m matrix of w_{ji}\n  w_m_T <- t(t(f_T)*alpha)/f0_T  # n by m matrix of w_{ji}\n  if (m == 1) {\n    S_alpha <- NULL\n  } else {\n    S_alpha <- (f_T[,1:(m-1)] - f_T[,m])/f0_T \n  }\n  S_mu <- matrix(0,nrow = n, ncol = m)\n  S_beta  <- matrix(0, nrow=n, ncol=q*m)\n  S_sigma <- matrix(0, nrow=n, ncol=q*m)\n  \n  for (j in 1:m){\n    H_1 <- colSums(matrix(H[,j,1],nr = t))\n    H_2 <- colSums(matrix(H[,j,2],nr = t))\n    S_mu[,j] <-w_m_T[,j] * H_1\n    S_sigma[,j] <-w_m_T[,j] * H_2\n    for (qq in 1:q){\n      H_1x <- x[,qq] * H[,j,1]\n      S_beta[, ((j-1)*q+qq)] <- colSums(matrix(H_1x,nr=t))\n    }\n  }\n  # S_mu    <- w_m_T*H[,,1] #nt by m\n  #FIXIT\n  \n  \n  S_eta   <- cbind(S_alpha, S_mu, S_beta, S_sigma)\n  \n  if (!is.null(z)) {\n    S_gam <- z*rowSums(S_mu)\n    S_eta <- cbind(S_eta,S_gam)\n  }\n  \n  n_lam <- q*(q+1)/2+2*q+2\n  S_lam <- matrix(0, nrow=n, ncol=n_lam*m)\n  xx    <- matrix(0, nrow=n, ncol=q*(q+1)/2)\n  \n  xx[,1:q] <- x*x\n  \n  if (q > 1) {\n    t <- q + 1\n    for (j in 1:(q-1)) {\n      for (i in (j+1):q) {\n        xx[,t] <- 2*x[,j]*x[,i]\n        t <- t+1\n      }\n    }\n  }\n  \n  for (j in 1:m) {\n    w_2 <- S_sigma[,j]\n    w_3 <- w_m[,j]*H[,j,3]\n    w_4 <- w_m[,j]*H[,j,4]\n    S_lam_1 <- cbind(w_3, x*w_2)\n    S_lam_2 <- cbind(w_4, x*w_3, xx*w_2)\n    S_lam[, ((j-1)*n_lam+1):(j*n_lam)] <- cbind(S_lam_1, S_lam_2)\n  }\n  \n  I_eta     <- t(S_eta) %*% S_eta/n\n  I_lam     <- t(S_lam) %*% S_lam/n\n  I_el      <- t(S_eta) %*% S_lam/n\n  if (qr(I_eta)$rank == nrow(I_eta)) {\n    I_eta_lam <- I_lam - t(I_el) %*% solve(I_eta,I_el)\n  } else {\n    stop(\"The critical value cannot be computed due to singularity of some matrices.\n         Please try a bootstrap version, regpanelmixCritBoot and regpanelmixMEMtestBoot.\")\n  }\n  \n  # generate u ~ N(0,I_eta_lam)\n  set.seed(123456)\n  e <- eigen(I_eta_lam, symmetric=TRUE)  # eigenvalue decomposition is slower than chol but more stable\n  u <- t(e$vec %*% (t(e$vec) * sqrt(e$val)) %*% matrix(rnorm(nrep*n_lam*m), nrow=n_lam*m))\n  \n  q_1 <- 1+q\n  q_2 <- 1+q+q*(q+1)/2\n  \n  LR <- matrix(0, nrow=nrep, ncol=m)\n  \n  if ( (parallel) && (is.null(cl)) ) {\n    ncpus <- parallel::detectCores()\n    cl <- parallel::makePSOCKcluster(rep(\"localhost\", ncpus))\n  }\n  \n  for (j in 1:m) {\n    I_j <- I_eta_lam[((j-1)*n_lam+1):(j*n_lam),((j-1)*n_lam+1):(j*n_lam)]\n    if (qr(I_j)$rank == nrow(I_j)) {\n      Z_j <- u[,((j-1)*n_lam+1):(j*n_lam)] %*% solve(I_j)    # nrep by n_lam matrix\n    } else {\n      stop(\"The critical value cannot be computed due to singularity of some matrices.\n           Please try a bootstrap version, regpanelmixCritBoot and regpanelmixMEMtestBoot.\")\n    }\n    # Lambda_1\n    V <- solve(I_j)\n    n_v <- ncol(V)\n    V_11 <- V[1:q_1,1:q_1]\n    V_12 <- V[1:q_1,(q_1+1):n_v]\n    V_21 <- t(V_12)\n    V_22 <- V[(q_1+1):n_v,(q_1+1):n_v]\n    Z_1 <- Z_j[,1:q_1]\n    Z_2 <- Z_j[,(q_1+1):ncol(Z_j)]\n    V_1_2 <- V_11 - V_12 %*% solve(V_22,V_21)\n    Z_1_2 <- Z_1 - Z_2 %*% solve(V_22,V_21)\n    inv_V_22 <- solve(V_22)\n    Z_22 <- t(inv_V_22[1,] %*% t(Z_2))\n    LR_1 <- rowSums((Z_1_2 %*% solve(V_1_2))*Z_1_2) + (1/inv_V_22[1,1])*(Z_22^2)*(Z_22<0)\n    \n    # Lambda_2\n    if (parallel) {\n      parallel::clusterSetRNGStream(cl, 123456)\n      LR_2 <- parallel::parRapply(cl, Z_j, LR_2.comp, I_j, q, ninits.crit)\n    } else {\n      LR_2    <- apply(Z_j, 1, LR_2.comp, I_j, q, ninits.crit)\n    }\n    LR[,j]  <- apply(cbind(LR_1,LR_2), 1, max)\n    }\n  \n  if (parallel) { parallel::stopCluster(cl) }\n  \n  max_EM <- apply(LR, 1, max)\n  max_EM_sort <- sort(max_EM)\n  qc <- floor(nrep*c(0.90,0.95,0.99))\n  crit <- max_EM_sort[qc]\n  \n  if (!is.null(values)) {\n    q1 <- length(values)\n    pvals <- rowMeans(t(matrix(rep.int(max_EM_sort,q1),ncol=q1)) >= values)\n  }\n  \n  return(list(crit = crit, pvals = pvals))\n  \n  } # end function regpanelmixCrit\n\n\n#' @description Computes the bootstrap critical values of the modified EM test.\n#' @export\n#' @title regpanelmixCritBoot\n#' @name regpanelmixCritBoot\n#' @param y n by 1 vector of data for y\n#' @param x n by q vector of data for x\n#' @param parlist The parameter estimates as a list containing alpha, mu, sigma, and gamma\n#' in the form of (alpha = (alpha_1, ..., alpha_m), mu = (mu_1, ..., mu_m),\n#' sigma = (sigma_1, ..., sigma_m), gam = (gamma_1, ..., gamma_m))\n#' @param z n by p matrix of regressor associated with gamma\n#' @param values 3 by 1 Vector of length 3 (k = 1, 2, 3) at which the p-values are computed\n#' @param ninits The number of initial candidates to be generated\n#' @param nbtsp The number of bootstrap observations; by default, it is set to be 199\n#' @param parallel Determines whether package \\code{doParallel} is used for calculation\n#' @param cl Cluster used for parallelization (optional)\n#' @return A list with the following items:\n#' \\item{crit}{3 by 3 matrix of (0.1, 0.05, 0.01 critical values), jth row corresponding to k=j}\n#' \\item{pvals}{A vector of p-values at k = 1, 2, 3}\nregpanelmixCritBoot <- function (y, x, parlist, z = NULL, values = NULL, ninits = 100,\n                            nbtsp = 199, parallel = TRUE, cl = NULL) {\n  if (normalregpanelmix.test.on) # initial values controlled by normalregpanelmix.test.on\n    set.seed(normalregpanelmix.test.seed)\n  \n  y  <- as.vector(y)\n  n  <- length(y)\n  x  <- as.matrix(x)\n  \n  alpha   <- parlist$alpha\n  mubeta  <- parlist$mubeta\n  sigma   <- parlist$sigma\n  gam   <- parlist$gam\n  m       <- length(alpha)\n  \n  pvals <- NULL\n  \n  # Generate bootstrap observations\n  ybset <- replicate(nbtsp, rnormregpanelmix(n = n, x = x, alpha = alpha, mubeta = mubeta, sigma = sigma))\n  \n  if (!is.null(z)) {\n    zgam <- as.matrix(z) %*% gam\n    ybset <- ybset + replicate(nbtsp, as.vector(zgam))\n  }\n  \n  if (parallel) {\n    if (is.null(cl))\n      cl <- makeCluster(detectCores())\n    registerDoParallel(cl)\n    out <- foreach (j.btsp = 1:nbtsp) %dopar% {\n      regpanelmixMEMtest (ybset[,j.btsp], x = x, m = m,\n                     z = z, ninits = ninits, crit.method = \"none\") }\n    on.exit(cl)\n  }\n  else\n    out <- apply(ybset, 2, regpanelmixMEMtest, x = x, m = m, z = z,\n                 ninits = ninits, crit.method = \"none\")\n  \n  emstat.b <- sapply(out, \"[[\", \"emstat\")  # 3 by nbstp matrix\n  \n  emstat.b <- t(apply(emstat.b, 1, sort))\n  \n  q <- ceiling(nbtsp*c(0.90,0.95,0.99))\n  crit <- emstat.b[, q]\n  \n  if (!is.null(values)) { pvals <- rowMeans(emstat.b > values) }\n  \n  return(list(crit = crit, pvals = pvals))\n}  # end function regpanelmixCritBoot\n",
    "created" : 1484296907527.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1961033290",
    "id" : "ED6EA741",
    "lastKnownWriteTime" : 1484340040,
    "last_content_update" : 1484340040914,
    "path" : "C:/Users/Jasmine/Dropbox/Dropbox/workspace/R/package/normalRegPanelMix/ToFix/regpanelmix_crit.R",
    "project_path" : "ToFix/regpanelmix_crit.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}