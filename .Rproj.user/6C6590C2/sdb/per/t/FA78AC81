{
    "collab_server" : "",
    "contents" : "#' @description  Sequentially performs MEM test given the data for y and x \n#' on the null hypothesis H_0: m = m_0 where m_0 is in {1, 2, ..., maxm}\n#' @export\n#' @title normalpanelmixMEMtestSeq\n#' @name normalpanelmixMEMtestSeq\n#' @param y n by 1 vector of data for y\n#' @param x n by q matrix of data for x (if exists)\n#' @param z n by p matrix of regressor associated with gamma\n#' @param maxm The maximum number of components set as null hypothesis in the mixture\n#' @param ninits The number of randomly drawn initial values.\n#' @param maxit The maximum number of iterations.\n#' @param nbtsp The number of bootstrap observations; by default, it is set to be 199\n#' @param parallel Determines whether package \\code{doParallel} is used for calculation\n#' @param cl Cluster used for parallelization; if it is \\code{NULL}, the system will automatically\n#' create a new one for computation accordingly.\n#' @param crit.bootstrap.from The minimum m in null hypothesis to have critical values \n#' calculated from bootstrap for the test statistics\n#' @return A list of with the following items:\n#' \\item{alpha}{maxm by maxm matrix, whose i-th column is a vector of alphas estimated given the null hypothesis m_0 = i}\n#' \\item{mu}{maxm by maxm matrix, whose i-th column is a vector of mus estimated given the null hypothesis m_0 = i}\n#' \\item{sigma}{maxm by maxm matrix, whose i-th column is a vector of sigmas estimated given the null hypothesis m_0 = i}\n#' \\item{beta}{A list of length maxm, whose i-th element is a q times i matrix of betas estimated given the null hypothesis m_0 = i}\n#' \\item{gam}{maxm by maxm matrix, whose i-th column is a vector of gammas estimated given the null hypothesis m_0 = i}\n#' \\item{emstat}{A maxm vector of values of modified EM statistics of the model at m_0 = 1, 2, ..., maxm}\n#' \\item{pvals}{A maxm by 3 matrix whose i-th row indicates a vector of p-values at k = 1, 2, 3}\n#' \\item{aic}{A maxm vector of Akaike Information Criterion of the fitted model at m_0 = 1, 2, ..., maxm}\n#' \\item{bic}{A maxm vector of Bayesian Information Criterion of the fitted model at m_0 = 1, 2, ..., maxm}\n#' \\item{loglik}{A maxm vector of log-likelihood values of the model at m_0 = 1, 2, ..., maxm}\n#' \\item{penloglik}{A maxm vector of penalized log-likelihood values of the model at m_0 = 1, 2, ..., maxm}\n#' \\item{pmle.result}{A list of output from normalpanelmixPMLE under the number of components selected by sequantial hypothesis testing}\n#' @examples\n#' data(faithful)\n#' attach(faithful)\n#' normalpanelmixMEMtestSeq(y = eruptions)\nnormalpanelmixMEMtestSeq <- function (y, x = NULL, z = NULL,  maxm = 3, ninits = 10, maxit = 2000,\n                                 nbtsp = 199, parallel = FALSE, cl = NULL,\n                                 crit.bootstrap.from = 3) {\n  # Compute the modified EM test statistic for testing H_0 of m components\n  # against H_1 of m+1 components for a univariate finite mixture of normals\n  \n  \n  if (!is.null(x))\n    return (regmixMEMtestSeq(y = y, x = x, z = z, maxm = maxm, ninits = ninits, maxit = maxit,\n                             nbtsp = nbtsp, parallel = parallel, cl = cl,\n                             crit.bootstrap.from = crit.bootstrap.from))\n  \n  y   <- as.vector(y)\n  n   <- length(y)\n  p   <- 0\n  if (!is.null(z)) {\n    z <- as.matrix(z)\n    p <- ncol(z)\n    gam <- matrix(0, nrow = p, ncol = maxm)\n  }\n  else \n    gam <- NULL\n  \n  out   <- vector('list', length = maxm)\n  aic    <- bic <- double(maxm)\n  pvals   <- emstat <- matrix(0, nrow = maxm, ncol = 3)\n  loglik  <- penloglik <- double(maxm)\n  \n  alpha   <- mu <- sigma <- matrix(0, nrow = maxm, ncol = maxm)\n  \n  # Test H_0:m=1, H_0:m=2, ...\n  binit <- NULL\n  for (m in 1:maxm){\n    pmle.result   <- normalpanelmixPMLE(y = y, m = m, z = z, vcov.method = \"none\",\n                                   ninits = ninits, maxit = maxit, binit = binit)\n    loglik[m] <- loglik0 <- pmle.result$loglik\n    penloglik[m] <- penloglik0 <- pmle.result$penloglik\n    aic[m]  <- pmle.result$aic\n    bic[m]  <- pmle.result$bic\n    \n    parlist <- pmle.result$parlist\n    alpha0  <- parlist$alpha\n    mu0     <- parlist$mu\n    sigma0  <- parlist$sigma\n    gam0  <- parlist$gam\n    \n    alpha[,m] <- c(alpha0, double(maxm - m))\n    mu[,m]     <- c(mu0, double(maxm - m))\n    sigma[,m] <- c(sigma0, double(maxm - m))\n    \n    cat(sprintf(\"%d-component model estimate:\\n\",m))\n    tab = as.matrix(rbind(alpha0, mu0, sigma0))\n    rownames(tab) <- c(\"alpha\", \"mu\", \"sigma\")\n    colnames(tab) <- c(paste(\"comp\", \".\", 1:m, sep = \"\"))\n    print(tab, digits = 4)\n    \n    if (!is.null(z)){\n      gam[, m] <- gam0\n      cat(\"gam =\", gam0,\"\\n\")\n    }\n    cat(sprintf(\"\\nAIC, BIC, and log-likelihood of 1 to %.i\", m), \"component models \\n\")\n    cat(c(\"AIC    =\", sprintf(' %.2f', aic[1:m])), \"\\n\")\n    cat(c(\"BIC    =\", sprintf(' %.2f', bic[1:m])), \"\\n\")\n    cat(c(\"loglik =\", sprintf('%.2f', loglik[1:m])), \"\\n\\n\")\n    \n    if (m <= maxm){\n      \n      cat(sprintf(\"Testing the null hypothesis of %d components\\n\", m))\n      \n      an    <- anFormula(parlist = parlist, m = m, n = n)\n      par1  <- normalpanelmixMaxPhi(y = y, parlist = parlist, z = z, an = an,\n                               ninits = ninits, maxit = maxit, parallel = parallel)\n      emstat.m  <- 2*(par1$penloglik - loglik0)\n      \n      # use the estimate of b as one of the initial values\n      binit <- par1$coefficient\n      \n      cat(c(\"modified EM-test statitic \", sprintf('%.3f',emstat.m)),\"\\n\")\n      if (m <= crit.bootstrap.from) {\n        em.out <- normalpanelmixCrit(y=y, parlist=parlist, z=z, values = emstat.m)\n        cat(c(\"asymptotic p-value       \", sprintf('%.3f',em.out$pvals)),\"\\n \\n\")\n      } else {\n        em.out <- normalpanelmixCritBoot(y=y, parlist=parlist, z=z, values = emstat.m,\n                                    ninits = ninits, nbtsp = nbtsp, parallel = parallel, cl = cl)\n        cat(c(\"bootstrap p-value        \", sprintf('%.3f',em.out$pvals)),\"\\n \\n\")\n      }\n      pvals[m,]     <- em.out$pvals\n      emstat[m,]    <- emstat.m\n    }\n  }\n  \n  for (m in 1:maxm)\n    if ( pvals[m,2] >= 0.05 ) {\n      cat(sprintf(\"\\nThe number of components selected by Sequential Hypothesis Testing (alpha=0.05) = %.i\", m), \" \\n\")\n      cat(sprintf(\"The number of components selected by AIC = %.i\", which.min(aic)), \" \\n\")\n      cat(sprintf(\"The number of components selected by BIC = %.i\", which.min(bic)), \" \\n\")\n      binit <- as.vector(c(alpha[1:m,m], mu[1:m,m], sigma[1:m,m],  gam[,m]))\n      pmle.result   <- normalpanelmixPMLE(y = y, m = m, z = z,\n                                     ninits = 2, maxit = maxit, binit = binit)\n      cat(sprintf(\"\\nThe summary of the estimated %.i\", m), \"component model: \\n\")\n      print(summary(pmle.result))\n      break\n    }\n  \n  a = list(alpha = alpha, mu = mu, sigma = sigma, gam = gam, emstat = emstat, pvals = pvals, aic = aic, bic = bic, loglik = loglik, penloglik = penloglik, pmle.result = pmle.result)\n  \n  a\n}  # end normalpanelmixMEMtestSeq\n\n#' Performs MEM test given the data for y and x on the null hypothesis H_0: m = m_0.\n#' @export\n#' @title normalpanelmixMEMtest\n#' @name normalpanelmixMEMtest\n#' @param y n by 1 vector of data\n#' @param x n by q matrix of data for x (if exists)\n#' @param m The number of components in the mixture defined by a null hypothesis, m_0\n#' @param z n by p matrix of regressor associated with gamma\n#' @param tauset A set of initial tau value candidates\n#' @param an a term used for penalty function\n#' @param ninits The number of randomly drawn initial values.\n#' @param crit.method Method used to compute the variance-covariance matrix, one of \\code{\"none\"},\n#' \\code{\"asy\"}, and \\code{\"boot\"}. The default option is \\code{\"asy\"}. When \\code{method = \"asy\"},\n#' the p-values are computed based on an asymptotic method. When \\code{method = \"OPG\"},\n#' the p-values are generated by bootstrapping.\n#' @param nbtsp The number of bootstrap observations; by default, it is set to be 199\n#' @param cl Cluster used for parallelization; if it is \\code{NULL}, the system will automatically\n#' create a new one for computation accordingly.\n#' @param parallel Determines whether package \\code{doParallel} is used for calculation\n#' @return A list of class \\code{normalpanelmix} with items:\n#' \\item{coefficients}{A vector of parameter estimates. Ordered as \\eqn{\\alpha_1,\\ldots,\\alpha_m,\\mu_1,\\ldots,\\mu_m,\\sigma_1,\\ldots,\\sigma_m,\\gam}.}\n#' \\item{parlist}{The parameter estimates as a list containing alpha, mu, and sigma (and gam if z is included in the model).}\n#' \\item{vcov}{The estimated variance-covariance matrix.}\n#' \\item{loglik}{The maximized value of the log-likelihood.}\n#' \\item{penloglik}{The maximized value of the penalized log-likelihood.}\n#' \\item{aic}{Akaike Information Criterion of the fitted model.}\n#' \\item{bic}{Bayesian Information Criterion of the fitted model.}\n#' \\item{postprobs}{n by m matrix of posterior probabilities for observations}\n#' \\item{components}{n by 1 vector of integers that indicates the indices of components\n#' each observation belongs to based on computed posterior probabilities}\n#' \\item{call}{The matched call.}\n#' \\item{m}{The number of components in the mixture.}\n#' @examples\n#' data(faithful)\n#' attach(faithful)\n#' normalpanelmixMEMtest(y = eruptions, m = 1, crit.method = \"asy\")\n#' normalpanelmixMEMtest(y = eruptions, m = 2, crit.method = \"asy\")\nnormalpanelmixMEMtest <- function (y, x = NULL, m = 2, z = NULL, an = NULL, tauset = c(0.1,0.3,0.5),\n                              ninits = 10,\n                              crit.method = c(\"asy\", \"boot\", \"none\"), nbtsp = 199,\n                              cl = NULL,\n                              parallel = FALSE) {\n  # Compute the modified EM test statistic for testing H_0 of m components\n  # against H_1 of m+1 components for a univariate finite mixture of normals\n  if (!is.null(x))\n    return (regmixMEMtest(y = y, x = x, m = m, z = z, tauset = tauset, an = an,\n                          ninits = ninits, crit.method = crit.method, nbtsp = nbtsp,\n                          cl = cl, parallel = parallel))\n  y     <- as.vector(y)\n  n     <- length(y)\n  if (!is.null(z)) {z <- as.matrix(z)}\n  crit.method <- match.arg(crit.method)\n  \n  pmle.result    <- normalpanelmixPMLE(y=y, m=m, z=z, vcov.method = \"none\", ninits=ninits)\n  loglik0 <- pmle.result$loglik\n  \n  if (is.null(an)){ an <- anFormula(parlist = pmle.result$parlist, m = m, n = n) }\n  \n  par1  <- normalpanelmixMaxPhi(y=y, parlist=pmle.result$parlist, z=z,\n                           an=an, tauset = tauset, ninits=ninits,\n                           parallel = parallel, cl = cl)\n  \n  \n  emstat  <- 2*(par1$penloglik - loglik0)\n  # emstat  <- 2*(par1$loglik - loglik0)\n  \n  if (crit.method == \"asy\"){\n    result  <- normalpanelmixCrit(y=y, parlist=pmle.result$parlist, z=z, values=emstat)\n  } else if (crit.method == \"boot\") {\n    result  <- normalpanelmixCritBoot(y=y, parlist= pmle.result$parlist, z=z, values=emstat,\n                                 ninits=ninits, nbtsp=nbtsp, parallel, cl=cl)\n  } else {\n    result <- list()\n    result$crit <- result$pvals <- rep(NA,3)\n  }\n  \n  a <- list(emstat = emstat, pvals = result$pvals, crit = result$crit, crit.method = crit.method,\n            parlist = pmle.result$parlist, call = match.call(), m = m, label = \"MEMtest\")\n  \n  class(a) <- \"normalregMix\"\n  \n  a\n  \n}  # end normalpanelmixMEMtest\n",
    "created" : 1484030737992.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2042145648",
    "id" : "FA78AC81",
    "lastKnownWriteTime" : 1484031103,
    "last_content_update" : 1484031103089,
    "path" : "C:/Users/Jasmine/Dropbox/Dropbox/workspace/R/package/normalRegPanelMix/R/normalpanelmix_test.R",
    "project_path" : "R/normalpanelmix_test.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}