{
    "collab_server" : "",
    "contents" : "hermite <- function(Z, sigma)\n# Computes the normalized Hermite polynomial for computing\n# the critical values and p-values of the modified EM test\n# Input\n#   Z (n by m) : normalized data\n#  sigma (m by 1): parameters\n# Output\n#   H (n by m by 4): normalized Hermite polynomials\n{\nn <- nrow(Z)\nm    <- length(sigma)\n\nH <- array(0,dim=c(n,m,4))\nH[,,1] <- Z/sigma\nH[,,2] <- t(t(Z^2-1)/2/sigma^2)\nH[,,3] <- t(t(Z^3-3*Z)/6/sigma^3)\nH[,,4] <- t(t(Z^4-6*Z^2+3)/24/sigma^4)\nreturn(H)\n}  # end function hermite\n\n\ntKR <- function (a,b) {\n  # Computes the transpose of the Khatri-Rao product of t(a) and t(b)\n  n <- nrow(a)\n  k <- ncol(a)\n  KR <- matrix(unlist(lapply(1:k, function(i) (a[,i]*b))),nrow=n)\n  KR\n}\n\n\ncoef.to.list <- function(coefficients, z = NULL) {\n# ã€€Convert coefficients to list\nlen     <- length(coefficients)\np       <- 0\ngam   <- NULL\n\nif (!is.null(z)) {\n  z <- as.matrix(z)\n  p <- ncol(z)\n  gam <- coefficients[(len-p+1):len]\n}\n\nm <- (len-p)/3\nif (round(m) != m) {\n  stop(\"The dimension of the coefficients is incompatible with z. Please check the data.\")\n}\n\nparam   <- matrix(coefficients[1:(len-p)], nrow=m, ncol=3)\nalpha   <- param[, 1]\nmu      <- param[, 2]\nsigma   <- param[, 3]\n\na = list(alpha = alpha, mu = mu, sigma = sigma, gam = gam)\n\na\n\n}\n\n#' @description Generates mixed normal random variables with regressor x\n#' @title rnormregmix\n#' @name rnormregmix\n#' @param n The number of observations\n#' @param x n by k-1 matrix that does NOT include a constant\n#' @param alpha m by 1 vector that represents proportions of components\n#' @param mubeta k by m matrix that represents (mu times k regression coefficients) on x for m components\n#' @param sigma m by 1 vector that represents sd of components\n#' @return n by 1 vector that is formed by regressor x\nrnormregmix <- function (n, x = NULL, alpha, mubeta, sigma) {\n  # Generates mixed normal random variables with regressor x\n  # Input\n  #  n : number of observations\n  #   x : (n by k-1) matrix NOT including a constant\n  #   alpha  : m-vector\n  #  mubeta  : k by m matrix\n  #  sigma  : m-vector\n  # Output\n  #  y : n by 1 vector\n  # if (normalregMix.test.on) # initial values controlled by normalregMix.test.on\n  #   set.seed(normalregMix.test.seed)\n\n  m     <- length(alpha)\n  mubeta   <- matrix(mubeta, ncol=m)\n\n  if (!is.null(x)){\n    x <- as.matrix(x)\n    if (nrow(x) != n) { stop(\"y and x must have the same number of rows.\") }\n    x1   <- cbind(1,x)\n    ii   <- sample(m, n, replace=TRUE, prob=alpha)\n    y   <- rnorm(n, mean = rowSums(x1*t(mubeta[, ii])), sd = sigma[ii])\n  } else {\n    ii   <- sample(m, n, replace=TRUE, prob=alpha)\n    y   <- rnorm(n, mean = mubeta[, ii], sd = sigma[ii])\n  }\n\n  y\n\n}  # end function rnormregmix\n\n\n\n#' @description Computes omega_{j|i} defined in (2.1) of Maitra and Melnykov (2010)\n#' @export\n#' @title omega.ji\n#' @name omega.ji\n#' @param phi_i 3 by 1 column consisting of alpha, mu, sigma of ith component\n#' @param phi_j 3 by 1 column consisting of alpha, mu, sigma of jth component\n#' @return omega_{j|i}\n#' @references Maitra, R., and Melnykov, V. (2010)\n#' Simulating Data to Study Performance of Finite Mixture Modeling and Model-Based Clustering Algorithms,\n#' \\emph{Journal of Computational and Graphical Statistica},\n#' \\bold{19}, 354--376.\n# Returns a misclassification rate omega_ji given two components i, j,\n# i.e. the probability of choosing component j where\n# the true model is ith component.\nomega.ji <- function(phi_i, phi_j) {\n  alpha_i <- phi_i[1]\n  alpha_j <- phi_j[1]\n  mu_i <- phi_i[2]\n  mu_j <- phi_j[2]\n  sigma_i <- phi_i[3]\n  sigma_j <- phi_j[3]\n\n  a <- (1/sigma_j^2 - 1/sigma_i^2)\n  b <- mu_i / sigma_i^2 - mu_j / sigma_j^2\n  c <- mu_j^2 / sigma_j^2 - mu_i^2 / sigma_i^2\n\n  if (sigma_i == sigma_j)\n    if (mu_i > mu_j)\n      omega_ji = pnorm((2 * log(alpha_j/alpha_i) - c)/(2*b),\n                       mean = mu_i, sd = sigma_i)\n  else\n    omega_ji = 1 - pnorm((2 * log(alpha_j/alpha_i) - c)/(2*b),\n                         mean = mu_i, sd = sigma_i)\n  else {\n    d <- 2 * log(alpha_j * sigma_i / (alpha_i * sigma_j)) - c + (b^2 / a)\n    da <- max(d/a, 0)\n    if (sigma_i > sigma_j)\n      omega_ji = pnorm(sqrt(da)-b/a, mean = mu_i, sd = sigma_i) -\n      pnorm(-sqrt(da)-b/a, mean = mu_i, sd = sigma_i)\n    else\n      omega_ji = 1 +\n      pnorm(-sqrt(da)-b/a, mean = mu_i, sd = sigma_i) -\n      pnorm(sqrt(da)-b/a, mean = mu_i, sd = sigma_i)\n  }\n  return (omega_ji)\n}\n\n#' @description Computes omega_{12} defined in Maitra and Melnykov (2010)\n#' @export\n#' @title omega.12\n#' @name omega.12\n#' @param parlist The parameter estimates as a list containing alpha, mu, sigma, and gam\n#' in the form of (alpha = (alpha_1, ..., alpha_m), mu = (mu_1, ..., mu_m),\n#' sigma = (sigma_1, ..., sigma_m), gam = (gam_1, ..., gam_m))\n#' @return The misclassification rate omega_ij\n#' @references Maitra, R., and Melnykov, V. (2010)\n#' Simulating Data to Study Performance of Finite Mixture Modeling and Model-Based Clustering Algorithms,\n#' \\emph{Journal of Computational and Graphical Statistica},\n#' \\bold{19}, 354--376.\nomega.12 <- function(parlist)\n  # Computes omega_{12} for testing H_0:m=2 against H_1:m=3\n{\n  phi1 <- c(alpha = parlist$alpha[1], mu = parlist$mu[1], sigma = parlist$sigma[1])\n  phi2 <- c(alpha = parlist$alpha[2], mu = parlist$mu[2], sigma = parlist$sigma[2])\n\n  part1 <- omega.ji(phi1, phi2)\n  part2 <- omega.ji(phi2, phi1)\n\n  return((part1 + part2) / 2)\n}  # end function omega.12\n\n\n#' Computes omega_{12} and omega_{23} defined in Maitra and Melnykov (2010)\n#' @export\n#' @title omega.123\n#' @name omega.123\n#' @param parlist The parameter estimates as a list containing alpha, mu, sigma, and gamma\n#' in the form of (alpha = (alpha_1, ..., alpha_m), mu = (mu_1, ..., mu_m),\n#' sigma = (sigma_1, ..., sigma_m), gam = (gamma_1, ..., gamma_m))\n#' @return A 2 by 1 vector whose first element is omega_12 and second element is omega_23\n#' @references Maitra, R., and Melnykov, V. (2010)\n#' Simulating Data to Study Performance of Finite Mixture Modeling and Model-Based Clustering Algorithms,\n#' \\emph{Journal of Computational and Graphical Statistica},\n#' \\bold{19}, 354--376.\nomega.123 <- function(parlist)\n{\n  phi1 <- c(alpha = parlist$alpha[1], mu = parlist$mu[1], sigma = parlist$sigma[1])\n  phi2 <- c(alpha = parlist$alpha[2], mu = parlist$mu[2], sigma = parlist$sigma[2])\n  phi3 <- c(alpha = parlist$alpha[3], mu = parlist$mu[3], sigma = parlist$sigma[3])\n\n  part1 <- omega.ji(phi1, phi2)\n  part2 <- omega.ji(phi2, phi1)\n  w12 <- (part1 + part2)/2\n\n  part3 <- omega.ji(phi2, phi3)\n  part4 <- omega.ji(phi3, phi2)\n  w23 <- (part3 + part4)/2\n\n  return(c(w12, w23))\n\n}  # end function omega.123\n\n#' @description Computes omega_{12}, omega_{23}, and omega_{34} defined in Maitra and Melnykov (2010)\n#' @export\n#' @title omega.1234\n#' @name omega.1234\n#' @param parlist The parameter estimates as a list containing alpha, mu, sigma, and gamma\n#' in the form of (alpha = (alpha_1, ..., alpha_m), mu = (mu_1, ..., mu_m),\n#' sigma = (sigma_1, ..., sigma_m), gam = (gamma_1, ..., gamma_m))\n#' @return A 3 by 1 vector consisting of omega_12, omega_23, and omega_34\n#' @references Maitra, R., and Melnykov, V. (2010)\n#' Simulating Data to Study Performance of Finite Mixture Modeling and Model-Based Clustering Algorithms,\n#' \\emph{Journal of Computational and Graphical Statistica},\n#' \\bold{19}, 354--376.\nomega.1234 <- function(parlist)\n{\n  phi1 <- c(alpha = parlist$alpha[1], mu = parlist$mu[1], sigma = parlist$sigma[1])\n  phi2 <- c(alpha = parlist$alpha[2], mu = parlist$mu[2], sigma = parlist$sigma[2])\n  phi3 <- c(alpha = parlist$alpha[3], mu = parlist$mu[3], sigma = parlist$sigma[3])\n  phi4 <- c(alpha = parlist$alpha[4], mu = parlist$mu[4], sigma = parlist$sigma[4])\n\n  part1 <- omega.ji(phi1, phi2)\n  part2 <- omega.ji(phi2, phi1)\n  w12 <- (part1 + part2)/2\n\n  part3 <- omega.ji(phi2, phi3)\n  part4 <- omega.ji(phi3, phi2)\n  w23 <- (part3 + part4)/2\n\n  part5 <- omega.ji(phi3, phi4)\n  part6 <- omega.ji(phi4, phi3)\n  w34 <- (part5 + part6)/2\n\n  return(c(w12, w23, w34))\n\n}  # end function omega.1234\n\ncoef.to.list <- function(coefficients, z = NULL) {\n  # Convert coefficients to list\n  len     <- length(coefficients)\n  p       <- 0\n  gam   <- NULL\n\n  if (!is.null(z)) {\n    z <- as.matrix(z)\n    p <- ncol(z)\n    gam <- coefficients[(len-p+1):len]\n  }\n\n  m <- (len-p)/3\n  if (round(m) != m) {\n    stop(\"The dimension of the coefficients is incompatible with z. Please check the data.\")\n  }\n\n  param   <- matrix(coefficients[1:(len-p)], nrow=m, ncol=3)\n  alpha   <- param[, 1]\n  mu      <- param[, 2]\n  sigma   <- param[, 3]\n\n  a = list(alpha = alpha, mu = mu, sigma = sigma, gam = gam)\n\n  a\n\n}\n",
    "created" : 1484297169328.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1665411293",
    "id" : "881A0840",
    "lastKnownWriteTime" : 1484337172,
    "last_content_update" : 1484337172739,
    "path" : "C:/Users/Jasmine/Dropbox/Dropbox/workspace/R/package/normalRegPanelMix/R/other_funcs.R",
    "project_path" : "R/other_funcs.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}